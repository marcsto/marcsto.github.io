<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probabilistic Chess</title>
    <link rel="stylesheet" href="static/styles.css">
    <script src="static/ai2.js"></script>
    
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script> -->
    <!-- <script type="module">
        import { Chess } from 'https://cdn.jsdelivr.net/npm/chess.js@latest/dist/chess.min.js'
      </script> -->
    <!-- <script type="module" src="https://cdn.jsdelivr.net/npm/chess.js@latest/dist/chess.min.js"></script> -->
    <!-- <script type="module" src="static/chess.min.js"></script> -->
    <!-- <script src="static/chess.min.js"></script> -->
    <script src="static/chess.js"></script>
    <!-- <script src="static/chess.js"></script> -->
    
    <script src="static/probchess.js"></script>
    <style>
        /* body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        } */
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 11.5vmin);
            grid-template-rows: repeat(8, 11.5vmin);
            border: 2px solid #333;
            margin-bottom: 20px;
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .black {
            background-color: #769656;
        }
        .white {
            background-color: #eeeed2;
        }
        .piece {
            width: 80%;
            height: 80%;
            cursor: pointer;
        }
        .probability {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 1.5vmin;
            color: #333;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px;
            border-radius: 3px;
        }
        .status {
            font-size: 15px;
            width: 300px;
            line-height: 40px; /* Adjust line height to match the dice height */
        }


        /* Dice */
        .dice {
            width: 40px;
            height: 40px;
            position: relative;
            transform-style: preserve-3d;
        }

        .face {
            width: 40px;
            height: 40px;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            background: #1e1e1e;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); }
        .face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }

        @keyframes roll-happy {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(90deg) rotateY(90deg); }
            50% { transform: rotateX(180deg) rotateY(180deg); }
            75% { transform: rotateX(270deg) rotateY(270deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        @keyframes roll-sad {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(90deg) rotateY(90deg); }
            50% { transform: rotateX(180deg) rotateY(180deg); }
            75% { transform: rotateX(270deg) rotateY(270deg); }
            100% { transform: rotateX(360deg) rotateY(270deg); }
        }

        .rolling-happy {
            animation: roll-happy 1s cubic-bezier(0.33, 1, 0.68, 1) forwards;
        }

        .rolling-sad {
            animation: roll-sad 1s cubic-bezier(0.33, 1, 0.68, 1) forwards;
        }

        .status-container {
            display: flex;
            align-items: center;
            height: 100vh; /* Ensure the container takes full viewport height */
            justify-content: center; /* Center horizontally */
        }

        .board-panel-container {
            display: flex;
            margin-top: 20px;
        }


        /* Side panel */
        .side-panel-container {
            height: 60%;
            margin-left: 20px;
        }
        .table-container {
            width: 300px;
            height: 700px;
            overflow-y: auto;
            background-color: #2b2b2b;
            margin-bottom: 20px;
        }
        #chessTable {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #444;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #333;
        }
        tr:nth-child(even) {
            background-color: #2b2b2b;
        }

        thead tr {
            background-color: #444; /* Ensure the sticky header has a background color */
        }

        thead tr:nth-child(1) th, 
        thead tr:nth-child(2) th, 
        thead tr:nth-child(2) td {
            position: sticky;
            top: 0;
            z-index: 2;
        }

        thead tr:nth-child(2) th, 
        thead tr:nth-child(2) td {
            top: 32px; /* Adjust this value based on the height of your first row */
        }

        .move {
            cursor: pointer;
        }

        .highlight {
            background-color: #0055a5;
        }
        .square-selected {
            background-color: rgba(250, 250, 0, 0.5);
        }

        .piece-selected {
            border: 2px solid #0055a5;
        }

        .piece-turn-to-play {
            /* Give a suble highlight to the color of the piece */
            filter: drop-shadow(0 0 5px #0055a5);
        }

        /* Use media query to make the side panel under the chessboard on smaller screens */
        @media (max-width: calc(92vmin + 350px)) {
            .board-panel-container {
                flex-direction: column;
                align-items: center;
            }
            .side-panel-container {
                margin-left: 0;
            }
            
        }
    </style>
</head>
<body>
    
    <div class="board-panel-container">
        <div class="chessboard" id="chessboard"></div>
        <div class="side-panel-container">
            <div id="moveTableDiv" class="table-container">
                <table id="chessTable">
                    <thead>
                        <tr>
                            <th></th>
                            <th><center><div class="dice" id="dicew">
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                            </div></center></th>
                            <th><center><div class="dice" id="diceb">
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                            </div></center></th>
                        </tr>
                        <tr>
                            <th></th>
                            <th>White</th>
                            <th>Black</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
            <div class="status" id="status">Welcome to Probabilistic Chess</div>
            <input type="checkbox" id="aib" onclick="requestAiMove()" checked>AI Plays Black</checkbox><br />
            <input type="checkbox" id="aiw" onclick="requestAiMove()">AI Plays White</checkbox><br />
            <!-- Add an AI strength drop down with Moderate, Moderate, Hard, Extreme -->
            <label for="difficulty">AI Difficulty (black):</label>
            <select id="ai-strength" name="ai-strength">
                <option value="moderate" selected>Moderate (depth 10)</option>
                <option value="hard">Hard (em depth 10)</option>
                <option value="veryhard">Very Hard (em depth 15)</option>
                <option value="extreme">Extreme (em depth 20)</option>
            </select>
            <br /><br />
            <b>Rules:</b><br />
            <div style="width: 300px;">
                <ul style="list-style-position: inside; padding-left: 1.0em; text-indent: -1.4em;">
                    <li>Each square has a probability of successfully moving to it.</li>
                    <li>A happy-face dice-roll means the move was successful.</li>
                    <li>You win by capturing the king.</li>
                </ul>
            </div>
        </div>
    </div>
    <!-- Make a link to marc.ai with white text and underline -->
    
    <div>Marc Stogaitis & Guy Stogaitis | <a href="https://marc.ai" style="color: white; text-decoration: underline;">marc.ai</a></div>

    <script>
        const diceAnimationTime = 1000;
        const pieces = {
            'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
            'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
            'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
            'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
            'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg',
            'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
            'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
            'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
            'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
            'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
            'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
            'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg'
        };

        // Generate initial random probabilities for demonstration purposes
        let probabilities = Array.from({ length: 8 }, () => 
            Array.from({ length: 8 }, () => Math.random())
        );
        // Make sure the king's starting squares have at least a 10% probbility
        probabilities[0][4] = Math.max(probabilities[0][4], 0.1);
        probabilities[7][4] = Math.max(probabilities[7][4], 0.1);
        

        let currentFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        //currentFEN = "k7/7P/8/8/8/8/8/7K w - - 0 1" // Promo white
        // currentFEN = "k7/8/8/8/8/8/7p/K7 b - - 0 1" // Promo black
        // let currentFEN = "r3kb1r/ppp1ppp1/7p/8/4pn2/8/PPPP1P1q/RNB1K1R1 b Qkq - 0 15"
        //let currentFEN = "k7/8/K7/8/8/8/8/8 w - - 0 1";
        //let currentFEN = "r3q1k1/2b2p1p/pp3npQ/2p2N2/3pP3/3P1NP1/PP3P2/R1B2RK1 w - - 1 19"

        let lastClickedSquare = null;

        function createChessboard() {
            const chessboard = document.getElementById('chessboard');
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    if ((row + col) % 2 === 0) {
                        square.classList.add('white');
                    } else {
                        square.classList.add('black');
                    }

                    const prob = document.createElement('div');
                    prob.className = 'probability';
                    prob.textContent = (probabilities[row][col] * 100).toFixed(0) + '%';
                    square.appendChild(prob);

                    chessboard.appendChild(square);
                }
            }

            updateBoardFromFEN(currentFEN);
            addDragAndDropListeners();
            addClickListeners();
        }

        function addDragAndDropListeners() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                square.addEventListener('dragover', handleDragOver);
                square.addEventListener('drop', handleDrop);
            });

            const pieces = document.querySelectorAll('.piece');
            pieces.forEach(piece => {
                piece.addEventListener('dragstart', handleDragStart);
            });
        }

        function handleDragStart(event) {
            event.dataTransfer.setData('text/plain', event.target.dataset.piece);
            event.dataTransfer.setData('startRow', event.target.dataset.startRow);
            event.dataTransfer.setData('startCol', event.target.dataset.startCol);
        }

        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDrop(event) {
            console.log('handleDrop');
            event.preventDefault();
            const piece = event.dataTransfer.getData('text/plain');
            const startRow = event.dataTransfer.getData('startRow');
            const startCol = event.dataTransfer.getData('startCol');
            const endRow = event.target.closest('.square').dataset.row;
            const endCol = event.target.closest('.square').dataset.col;

            const pieceImg = document.querySelector(`img[data-piece='${piece}'][data-start-row='${startRow}'][data-start-col='${startCol}']`);
            const targetSquare = document.querySelector(`.square[data-row='${endRow}'][data-col='${endCol}']`);

            // Remove any existing piece in the target square
            const existingPiece = targetSquare.querySelector('.piece');
            if (existingPiece) {
                existingPiece.remove();
            }

            targetSquare.appendChild(pieceImg);

            pieceImg.dataset.startRow = endRow;
            pieceImg.dataset.startCol = endCol;

            sendMoveToServer(startRow, startCol, endRow, endCol, currentFEN);
        }

        function addClickListeners() {
            const pieces = document.querySelectorAll('.piece');
            pieces.forEach(piece => {
                piece.addEventListener('click', handlePieceClick);
            });

            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                square.addEventListener('click', handleSquareClick);
            });
        }

        function handlePieceClick(event) {
            console.log('Piece clicked');
            console.log(event);
            //handleSquareClick(event);
        }

        function handleSquareClick(event) {
            console.log('Square clicked ');
            console.log(event);

            let clickedSquare = event.target.closest('.square');
            let clickedPiece = clickedSquare.querySelector('.piece');
            
            console.log("clicked_square", clickedSquare);

            if (lastClickedSquare == null) {
                console.log('Selecting a piece to move.');
                turn = currentFEN.split(' ')[1];
                if (turn === 'w' && clickedPiece.dataset.piece === clickedPiece.dataset.piece.toLowerCase()
                    || turn === 'b' && clickedPiece.dataset.piece === clickedPiece.dataset.piece.toUpperCase()) {
                    console.log('Not your turn to play.');
                    document.getElementById('status').textContent = 'Not your turn to play.';
                    return;
                }

                lastClickedSquare = clickedSquare;
                if (!clickedPiece) {
                    console.log('No piece in the selected square. Ignoring move.');
                    lastClickedSquare = null;
                    return;
                }
                clickedPiece.classList.add('piece-selected');
            } else if (lastClickedSquare == clickedSquare) {
                console.log('Deselecting previously selected piece');
                let lastClickedPiece = lastClickedSquare.querySelector('.piece');
                lastClickedPiece.classList.remove('piece-selected');
                lastClickedSquare = null;
            } else {
                console.log('Moving piece to selected square.');
                const startRow = lastClickedSquare.dataset.row;
                const startCol = lastClickedSquare.dataset.col;
                const endRow = clickedSquare.dataset.row;
                const endCol = clickedSquare.dataset.col;

                //const targetSquare = document.querySelector(`.square[data-row='${endRow}'][data-col='${endCol}']`);

                // Remove any existing piece in the target square
                const existingPiece = clickedSquare.querySelector('.piece');
                if (existingPiece) {
                    existingPiece.remove();
                }
                lastClickedPiece = lastClickedSquare.querySelector('.piece');
                clickedSquare.appendChild(lastClickedPiece);

                lastClickedPiece.dataset.startRow = endRow;
                lastClickedPiece.dataset.startCol = endCol;

                // clicked_square.classList.add('square-selected');
                lastClickedSquare = null;
                sendMoveToServer(startRow, startCol, endRow, endCol, currentFEN);
                
            }
        }

        function sendMoveToServer(startRow, startCol, endRow, endCol, fen) {
            const move = {
                startRow: parseInt(startRow),
                startCol: parseInt(startCol),
                endRow: parseInt(endRow),
                endCol: parseInt(endCol),
                fen: fen,
                probabilities: probabilities
            };
            data = probMove(move);
            
            console.log('probMoveResult:', data);
            if (data.is_illegal) {
                currentFEN = data.fen;
                probabilities = data.probabilities;
                updateBoardFromFEN(currentFEN);
                document.getElementById('status').textContent = data.status;
                return;
            }
            rollDice(data.played, data.turn === 'b' ? 'w' : 'b');
            setTimeout(() => {
                if (data.status) {
                    document.getElementById('status').textContent = data.status;
                }
                
                if (data.fen && data.probabilities) {
                    currentFEN = data.fen;
                    probabilities = data.probabilities;
                    updateBoardFromFEN(currentFEN);
                }

                if (data.move) {
                    const strikeThrough = data.played === 1 ? 0 : 1;
                    const turn_opposite = data.turn === 'b' ? 'w' : 'b';
                    addMoveToSidePanel(data.move, turn_opposite, strikeThrough, currentFEN);
                }
                
                if (data.winner) {
                    showWinner(data.winner);
                    return;
                }

                if (data.turn === 'b' && document.getElementById('aib').checked
                    || data.turn === 'w' && document.getElementById('aiw').checked) {
                    requestAiMove();
                }
            }, diceAnimationTime);
        }

        let stockfish = null;
        
        // stockfish.getBestMoveEm('k6q/8/7Q/8/8/8/8/K7 w - - 0 1', probabilities, function(data) {
        //     console.log('AI move received:', data);
        // })
        function requestAiMove() {
            if (stockfish == null) {
                stockfish = new StockfishEvaluator()
            }
            turn = currentFEN.split(' ')[1];
            if (turn === 'w' && document.getElementById('aiw').checked
                || turn === 'b' && document.getElementById('aib').checked) {
                console.log('Requesting AI move');
                
                var difficulty = document.getElementById("ai-strength").value;
                if (turn === 'w') {
                    // TEMP HACK
                    stockfish.getBestMove(currentFEN, onAiMove);
                } else if (difficulty === "moderate") {
                    stockfish.getBestMove(currentFEN, onAiMove);
                } else if (difficulty === "hard") {
                    stockfish.getBestMoveEm(currentFEN, probabilities, onAiMove, depth=10);
                } else if (difficulty === "veryhard") {
                    stockfish.getBestMoveEm(currentFEN, probabilities, onAiMove, depth=15);
                } else if (difficulty === "extreme") {
                    stockfish.getBestMoveEm(currentFEN, probabilities, onAiMove, depth=20);
                }
                
            }

        }

        function onAiMove(data) {
            console.log('AI move received:', data);
            if (data === null) {
                console.log('AI did not return a move (checkmate). Picking random move.');
                // Pick a random move in the following order:
                // 1. A move where the king captures a piece
                // 2. Any capture move
                // 3. Any move
                all_moves = get_all_moves(currentFEN);
                moves = all_moves.filter(move => move.piece.toLowerCase() === 'k' && move.captured);
                if (moves.length === 0) {
                    moves = all_moves.filter(move => move.captured);
                    if (moves.length === 0) {
                        moves = all_moves;
                    }
                }
                rnd_move = moves[Math.floor(Math.random() * moves.length)];
                rnd_move = chessMoveToIndices(rnd_move.from + rnd_move.to);
                data = rnd_move;
            }
            console.log('Playing AI move on board:', data);
            // Play the ai move as if the user had clicked on the start square and end square
            clicked_piece = document.querySelector(`img[data-start-row='${data.startRow}'][data-start-col='${data.startCol}']`);
            lastClickedSquare = null;
            event = { target: clicked_piece };
            handleSquareClick(event);
            event = { target: document.querySelector(`.square[data-row='${data.endRow}'][data-col='${data.endCol}']`) };
            handleSquareClick(event);
        }
       
        function updateBoardFromFEN(fen) {
            
            const chessboard = document.getElementById('chessboard');
            const squares = chessboard.querySelectorAll('.square');
            const board = new Chess(fen);
            
            const rows = ['8', '7', '6', '5', '4', '3', '2', '1'];
            const cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

            squares.forEach(square => {
                square.classList.remove('square-selected');
                const row = square.dataset.row;
                const col = square.dataset.col;
                // Convert from our row col to chess.js row col.
                const squareName = cols[col] + rows[row];
                // The format of desired piece is {type: 'r', color: 'b'}
                let desiredPiece = board.get(squareName);
                const existingPiece = square.querySelector('.piece');
                // Remove piece-selected class from all pieces
                if (existingPiece) {
                    existingPiece.classList.remove('piece-selected');
                }
                if (desiredPiece == null) {
                    // Remove any existing piece in the square
                    if (existingPiece) {
                        existingPiece.remove();
                    }
                } else {
                    side = desiredPiece.color
                    desiredPiece = desiredPiece.type
                    if (side === 'w') {
                        desiredPiece = desiredPiece.toUpperCase();
                    }

                    if (existingPiece) {
                        if (existingPiece.dataset.piece !== desiredPiece) {
                            // Replace the existing piece with the desired piece
                            existingPiece.src = pieces[desiredPiece];
                            existingPiece.dataset.piece = desiredPiece;
                        }
                    } else {
                        // Add the desired piece to the square
                        const pieceImg = document.createElement('img');
                        pieceImg.src = pieces[desiredPiece];
                        pieceImg.className = 'piece';
                        pieceImg.draggable = true;
                        pieceImg.dataset.piece = desiredPiece;
                        pieceImg.dataset.startRow = row;
                        pieceImg.dataset.startCol = col;
                        square.appendChild(pieceImg);
                    }
                }                
            });

            highlightPiecesToPlay(board.turn() === 'b');
            addDragAndDropListeners();
            addClickListeners();
        }

        function rollDice(finalFaceType, turn) {
            const dice = document.getElementById('dice' + turn);

            // Remove the existing rolling classes to reset the animation
            dice.classList.remove('rolling-happy', 'rolling-sad');

            // Force reflow to reset the animation
            void dice.offsetWidth;

            // Add the appropriate rolling class based on the finalFaceType parameter
            if (finalFaceType === 1) {
                dice.classList.add('rolling-happy');
            } else {
                dice.classList.add('rolling-sad');
            }
        }

        /**
         * Add a move to the side panel table
         * 
         * @param {string} humanReadableMove - The move to add
         * @param {number} strikeThrough - Whether to strike through the text of the move
         */
        function addMoveToSidePanel(humanReadableMove, moveTurn, strikeThrough, fen) {
            if (humanReadableMove === '') {
                alert('Please enter a move.');
                return;
            }
            const table = document.getElementById('chessTable').getElementsByTagName('tbody')[0];
            lastRow = null;
            if (table.rows.length === 0) {
                firstMove = true;
            } else {
                firstMove = false;
                lastRow = table.rows[table.rows.length - 1];
            }
            
            let cell = null;
            if (!firstMove && lastRow.cells[2].textContent === '' && moveTurn === 'b') {
                // If black move cell is empty, fill the previous row's black cell
                cell = lastRow.cells[2];
            } else {
                // Otherwise, create a new row for white move
                const newRow = table.insertRow();
                newRow.insertCell(0).textContent = table.rows.length;
                newRow.insertCell(1).textContent = '';
                newRow.insertCell(2).textContent = '';
                if (moveTurn === 'w') {
                    cell = newRow.cells[1];
                } else {
                    cell = newRow.cells[2];
                }
            }

            cell.textContent = humanReadableMove;
            cell.dataset.fen = fen;
            cell.classList.add('move');
            cell.addEventListener('click', handleHistoricalMoveClick)
            if (strikeThrough === 1) {
                cell.style.color = 'red';
            }
            moveTableDiv.scrollTop = moveTableDiv.scrollHeight;
        }

        function highlightPiecesToPlay(black_turn) {
            const pieces = document.querySelectorAll('.piece');
            pieces.forEach(piece => {
                if (black_turn) {
                    if (piece.dataset.piece === piece.dataset.piece.toLowerCase()) {
                        piece.classList.add('piece-turn-to-play');
                    } else {
                        piece.classList.remove('piece-turn-to-play');
                    }
                } else {
                    if (piece.dataset.piece === piece.dataset.piece.toUpperCase()) {
                        piece.classList.add('piece-turn-to-play');
                    } else {
                        piece.classList.remove('piece-turn-to-play');
                    }
                }
            });
        }

        function handleHistoricalMoveClick(event) {
            const move = event.target.textContent;
            const fen = event.target.dataset.fen;
            if (move === '') {
                return;
            }
            console.log('Historical move clicked:', move, fen);
            currentFEN = fen;
            updateBoardFromFEN(fen);
        }

        function doOnload() {
            rollDice(1, 'w');
            rollDice(1, 'b');
        }
        // Optional: Automatically roll the dice when the page loads
        window.onload = () => doOnload();
        

        createChessboard();


    </script>

    <div id="resultAnimation" class="hidden">
        <div id="resultMessage"></div>
    </div>
    <script src="static/winlose.js"></script>
</body>
</html>
