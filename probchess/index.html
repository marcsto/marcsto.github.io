<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probabilistic Chess</title>
    <link rel="stylesheet" href="static/styles.css">
    <link rel="stylesheet" href="static/probboard.css">
    <script src="static/chessutils.js"></script>
    <script src="static/chess.js"></script>
    <script src="static/probchess.js"></script>
    <script src="static/aisync.js"></script>
    <script src="static/ai-stockfish.js"></script>
    <script src="static/ai-montecarlo.js"></script>
    <script src="static/ai-alphabeta.js"></script>
    <script src="static/probboard.js"></script>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script> -->
    <!-- <script type="module">
        import { Chess } from 'https://cdn.jsdelivr.net/npm/chess.js@latest/dist/chess.min.js'
      </script> -->
    <!-- <script type="module" src="https://cdn.jsdelivr.net/npm/chess.js@latest/dist/chess.min.js"></script> -->
    <!-- <script type="module" src="static/chess.min.js"></script> -->
    <!-- <script src="static/chess.min.js"></script> -->
    
    <!-- <script src="static/chess.js"></script> -->
    
    
    <style>
        /* body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        } */
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
        }
        
        
        .status {
            font-size: 15px;
            width: 300px;
            line-height: 40px; /* Adjust line height to match the dice height */
        }

        /* Dice */
        .dice {
            width: 40px;
            height: 40px;
            position: relative;
            transform-style: preserve-3d;
        }

        .face {
            width: 40px;
            height: 40px;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            background: #1e1e1e;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); }
        .face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }

        @keyframes roll-happy {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(90deg) rotateY(90deg); }
            50% { transform: rotateX(180deg) rotateY(180deg); }
            75% { transform: rotateX(270deg) rotateY(270deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        @keyframes roll-sad {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(90deg) rotateY(90deg); }
            50% { transform: rotateX(180deg) rotateY(180deg); }
            75% { transform: rotateX(270deg) rotateY(270deg); }
            100% { transform: rotateX(360deg) rotateY(270deg); }
        }

        .rolling-happy {
            animation: roll-happy 1s cubic-bezier(0.33, 1, 0.68, 1) forwards;
        }

        .rolling-sad {
            animation: roll-sad 1s cubic-bezier(0.33, 1, 0.68, 1) forwards;
        }

        .status-container {
            display: flex;
            align-items: center;
            height: 100vh; /* Ensure the container takes full viewport height */
            justify-content: center; /* Center horizontally */
        }

        .board-panel-container {
            display: flex;
            margin-top: 20px;
        }


        /* Side panel */
        .side-panel-container {
            height: 60%;
            margin-left: 20px;
        }
        .table-container {
            width: 300px;
            height: 700px;
            overflow-y: auto;
            background-color: #2b2b2b;
            margin-bottom: 20px;
        }
        #chessTable {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #444;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #333;
        }
        tr:nth-child(even) {
            background-color: #2b2b2b;
        }

        thead tr {
            background-color: #444; /* Ensure the sticky header has a background color */
        }

        thead tr:nth-child(1) th, 
        thead tr:nth-child(2) th, 
        thead tr:nth-child(2) td {
            position: sticky;
            top: 0;
            z-index: 2;
        }

        thead tr:nth-child(2) th, 
        thead tr:nth-child(2) td {
            top: 40px; /* Adjust this value based on the height of your first row */
        }

        .move {
            cursor: pointer;
        }

        .highlight {
            background-color: #0055a5;
        }
        
        /* Use media query to make the side panel under the chessboard on smaller screens */
        @media (max-width: calc(92vmin + 350px)) {
            .board-panel-container {
                flex-direction: column;
                align-items: center;
            }
            .side-panel-container {
                margin-left: 0;
            }
            
        }
    </style>
</head>
<body>
    <div class="status" id="winner"></div>
    <div class="board-panel-container">
        <div class="chessboard" id="chessboard"></div>
        <div class="side-panel-container">
            <div id="moveTableDiv" class="table-container">
                <table id="chessTable">
                    <thead>
                        <tr>
                            <th></th>
                            <th><center><div class="dice" id="dicew">
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                            </div></center></th>
                            <th><center><div class="dice" id="diceb">
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                                <div class="face happy">ðŸ˜Š</div>
                                <div class="face sad">ðŸ˜¢</div>
                            </div></center></th>
                        </tr>
                        <tr>
                            <th></th>
                            <th>White</th>
                            <th>Black</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
            <div class="status" id="status">Welcome to Probabilistic Chess</div>
            <table>
                <tr>
                    <td>
                        <input type="checkbox" id="aiw" onclick="requestAiMove()">AI Plays White</checkbox>
                    </td><td>
                        <select id="ai-strength-w" name="ai-strength-w">
                            <option value="moderate">Moderate</option>
                            <option value="hard" selected>Hard Monte Carlo</option>
                            <option value="veryhard">Hard AlphaBetaEm</option>
                        </select>
                    </td>
                </tr><tr>
                    <td>
                        <input type="checkbox" id="aib" onclick="requestAiMove()" checked>AI Plays Black</checkbox>
                    </td><td>
                        <select id="ai-strength-b" name="ai-strength-b">
                            <option value="moderate">Moderate</option>
                            <option value="hard">Hard Monte Carlo</option>
                            <option value="veryhard" selected>Hard AlphaBetaEm</option>
                        </select>
                    </td>
                </tr>
            </table>
            
            <br /><br />
            <b>Rules:</b><br />
            <div style="width: 300px;">
                <ul style="list-style-position: inside; padding-left: 1.0em; text-indent: -1.4em;">
                    <li>Each square has a probability of successfully moving to it.</li>
                    <li>A happy-face dice-roll means the move was successful.</li>
                    <li>You win by capturing the king.</li>
                </ul>
            </div>
        </div>
    </div>
    <!-- Make a link to marc.ai with white text and underline -->
    
    <div>Marc Stogaitis & Guy Stogaitis | <a href="https://marc.ai" style="color: white; text-decoration: underline;">marc.ai</a></div>
    
    <script>
        let diceAnimationTime = 1000;
        // Generate initial random probabilities for demonstration purposes
        let probabilities = Array.from({ length: 8 }, () => 
            Array.from({ length: 8 }, () => Math.random())
        );
        // Make sure the king's starting squares have at least a 10% probbility
        probabilities[0][4] = Math.max(probabilities[0][4], 0.1);
        probabilities[7][4] = Math.max(probabilities[7][4], 0.1);

        function sendMoveToServer(startRow, startCol, endRow, endCol, fen) {
            const move = {
                startRow: parseInt(startRow),
                startCol: parseInt(startCol),
                endRow: parseInt(endRow),
                endCol: parseInt(endCol),
                fen: fen,
                probabilities: probabilities
            };
            data = probMove(move);
            
            console.log('probMoveResult:', data);
            if (data.is_illegal) {
                currentFEN = data.fen;
                probabilities = data.probabilities;
                updateBoardFromFEN(currentFEN);
                document.getElementById('status').textContent = data.status;
                return;
            }
            rollDice(data.played, data.turn === 'b' ? 'w' : 'b');
            setTimeout(() => {
                if (data.status) {
                    document.getElementById('status').textContent = data.status;
                }
                
                if (data.fen && data.probabilities) {
                    currentFEN = data.fen;
                    probabilities = data.probabilities;
                    updateBoardFromFEN(currentFEN);
                }

                if (data.move) {
                    const strikeThrough = data.played === 1 ? 0 : 1;
                    const turn_opposite = data.turn === 'b' ? 'w' : 'b';
                    addMoveToSidePanel(data.move, turn_opposite, strikeThrough, currentFEN);
                }
                
                if (data.winner) {
                    showWinner(data.winner);
                    return;
                }

                if (data.turn === 'b' && document.getElementById('aib').checked
                    || data.turn === 'w' && document.getElementById('aiw').checked) {
                    requestAiMove();
                }
            }, diceAnimationTime);
        }

        let aiStockfish = null;
        let aiMonteCarlo = null;
        let aiAlphaBetaEm = null;
        
        function playAiMove(difficulty) {
            if (difficulty === "moderate") {
                if (aiStockfish === null) {
                    aiStockfish = new StockfishAi();
                }
                aiStockfish.getBestMove(currentFEN, onAiMove);
            } else if (difficulty === "hard") {
                if (aiMonteCarlo === null) {
                    aiMonteCarlo = new MonteCarloAi();
                }
                aiMonteCarlo.getBestMove(currentFEN, probabilities, onAiMove, depth=10);
            } else if (difficulty === "veryhard") {
                if (aiAlphaBetaEm === null) {
                    aiAlphaBetaEm = new AlphaBetaEmAi();
                }
                aiAlphaBetaEm.getBestMove(currentFEN, probabilities, onAiMove, depth=3);    
            } else {
                console.error('Unknown difficulty:', difficulty);
                throw new Error('Unknown difficulty');
            }
        }
        // stockfish.getBestMoveEm('k6q/8/7Q/8/8/8/8/K7 w - - 0 1', probabilities, function(data) {
        //     console.log('AI move received:', data);
        // })
        function requestAiMove() {
            turn = currentFEN.split(' ')[1];
            if (turn === 'w' && document.getElementById('aiw').checked
                || turn === 'b' && document.getElementById('aib').checked) {
                console.log('Requesting AI move');
                
                if (document.getElementById('aiw').checked && document.getElementById('aib').checked) {
                    // Ai vs Ai. Play fast.
                    diceAnimationTime = 0;
                }
                
                var difficulty = document.getElementById("ai-strength-" + turn).value;
                playAiMove(difficulty);
            }

        }

        function onAiMove(data) {
            console.log('AI move received:', data);
            if (data === null) {
                console.log('AI did not return a move (checkmate). Picking random move.');
                // Pick a random move in the following order:
                // 1. A move where the king captures a piece
                // 2. Any capture move
                // 3. Any move
                all_moves = get_all_moves(currentFEN);
                moves = all_moves.filter(move => move.piece.toLowerCase() === 'k' && move.captured);
                if (moves.length === 0) {
                    moves = all_moves.filter(move => move.captured);
                    if (moves.length === 0) {
                        moves = all_moves;
                    }
                }
                rnd_move = moves[Math.floor(Math.random() * moves.length)];
                rnd_move = chessMoveToIndices(rnd_move.from + rnd_move.to);
                data = rnd_move;
            }
            console.log('Playing AI move on board:', data);
            // Play the ai move as if the user had clicked on the start square and end square
            clicked_piece = document.querySelector(`img[data-start-row='${data.startRow}'][data-start-col='${data.startCol}']`);
            lastClickedSquare = null;
            event = { target: clicked_piece };
            handleSquareClick(event);
            event = { target: document.querySelector(`.square[data-row='${data.endRow}'][data-col='${data.endCol}']`) };
            handleSquareClick(event);
        }

        function rollDice(finalFaceType, turn) {
            const dice = document.getElementById('dice' + turn);

            // Remove the existing rolling classes to reset the animation
            dice.classList.remove('rolling-happy', 'rolling-sad');

            // Force reflow to reset the animation
            void dice.offsetWidth;

            // Add the appropriate rolling class based on the finalFaceType parameter
            if (finalFaceType === 1) {
                dice.classList.add('rolling-happy');
            } else {
                dice.classList.add('rolling-sad');
            }
        }

        /**
         * Add a move to the side panel table
         * 
         * @param {string} humanReadableMove - The move to add
         * @param {number} strikeThrough - Whether to strike through the text of the move
         */
        function addMoveToSidePanel(humanReadableMove, moveTurn, strikeThrough, fen) {
            if (humanReadableMove === '') {
                alert('Please enter a move.');
                return;
            }
            const table = document.getElementById('chessTable').getElementsByTagName('tbody')[0];
            lastRow = null;
            if (table.rows.length === 0) {
                firstMove = true;
            } else {
                firstMove = false;
                lastRow = table.rows[table.rows.length - 1];
            }
            
            let cell = null;
            if (!firstMove && lastRow.cells[2].textContent === '' && moveTurn === 'b') {
                // If black move cell is empty, fill the previous row's black cell
                cell = lastRow.cells[2];
            } else {
                // Otherwise, create a new row for white move
                const newRow = table.insertRow();
                newRow.insertCell(0).textContent = table.rows.length;
                newRow.insertCell(1).textContent = '';
                newRow.insertCell(2).textContent = '';
                if (moveTurn === 'w') {
                    cell = newRow.cells[1];
                } else {
                    cell = newRow.cells[2];
                }
            }

            cell.textContent = humanReadableMove;
            cell.dataset.fen = fen;
            cell.classList.add('move');
            cell.addEventListener('click', handleHistoricalMoveClick)
            if (strikeThrough === 1) {
                cell.style.color = 'red';
            }
            moveTableDiv.scrollTop = moveTableDiv.scrollHeight;
        }

        function handleHistoricalMoveClick(event) {
            const move = event.target.textContent;
            const fen = event.target.dataset.fen;
            if (move === '') {
                return;
            }
            console.log('Historical move clicked:', move, fen);
            currentFEN = fen;
            updateBoardFromFEN(fen);
        }

        function doOnload() {
            rollDice(1, 'w');
            rollDice(1, 'b');
        }
        // Optional: Automatically roll the dice when the page loads
        window.onload = () => doOnload();
        

        createChessboard();


    </script>

    <div id="resultAnimation" class="hidden">
        <div id="resultMessage"></div>
    </div>
    <script src="static/winlose.js"></script>
    <script>
        // If the URL has a parameter called autoplay, enable the AI Plays White checkbox.
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('autoplay')) {
            document.getElementById('aiw').checked = true;
            requestAiMove();
        }
    </script>
</body>
</html>
